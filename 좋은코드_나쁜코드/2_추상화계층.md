### 널값 및 의사코드 규약

- 널 값 처리
    - `NullPointerException` `NullReferenceException` 등등 처리

- JAVA의 널 안전성 지원 시 사용

``` 
Element? getFifthElement(List<Element> elements) {
    if (elements.size() < 5) {
        return null; 
    }
    return elements[4];
}
```

- 널 안전성 대신 `Optional` 타입을 사용해도 좋음

### 추상화 계층 및 코드 품질의 핵심 요소

1. 가독성
    - 개발자가 코드베이스에 있는 모든 세부 사항을 이해하지 않아도 됨
    - 한두 개 정도의 계층과 몇개의 개념만 다루면 됨
2. 모듈화
    - 추상화 계층이 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부 사항이 외부에 드러나지 않도록 보장
3. 재사용성 및 일반화성
    - 하위 문제에 대한 해결책이 간결한 추상화 계층으로 제시되면 해당 하위 문제에 대한 해결책을 재사용하기 쉬워짐
4. 테스트 용이성
    - 각 하위 문제에 대한 해결책을 완벽하게 테스트하는 것이 쉬워짐

#### 예시

1. 모든 개념을 담고 있는 하나의 클래스 `TextSummarizer`

```mermaid
graph TD
A[텍스트 요약 기능이 필요한 코드]
A --> |의존| B(TextSummarizer)
```

- `TextSummarizer`가 너무 많은 기능 담당
    - 텍스트 요약
    - 중요도 계산
    - 중요한 명사, 형용사, 동사 추출
    - 텍스트를 단락으로 나누기
    - 단락 시작 찾기
    - 단락 끝 찾기

- 문제점
    - 단락 수를 계산하는 기능이 필요한 코드를 다른 문제에 재사용 못함
    - 중요도 계산 알고리즘이 바뀌어도 기능의 일부를 교체할 수 없음
    - 너무 광범위한 내용을 다루어 테스트 코드를 작성하기 어려움 (세부 사항 테스트 어려움)

2. 개선 1

```mermaid
graph TD
A[텍스트 요약 기능이 필요한 코드]
A --> |의존| B(TextSummarizer)
B --> C(ParagraphFinder) 
B --> D(TextImportanceScorer)
```

- `TextSummarizer`
    - 텍스트 요약
- `ParagraphFinder`
    - 텍스트를 단락으로 나누기
    - 단락 시작 찾기
    - 단락 끝 찾기
- `TextImportanceScorer`
    - 중요도 계산
    - 중요한 명사, 형용사, 동사 추출

- 변화
    - 각 클래스당 개념 몇 가지만 가져서 코드 이해가 쉬워짐
    - 테스트 코드를 작성하기 쉬워짐
    - 단락 수 계산이 필요한 다른 코드가 있다면 `ParagraphFinder`를 재사용하면 됨
    - 중요도 계산 로직과 같은 중요한 것을 더 자세히 테스트할 수 있음
- 추가적으로 개선사항
    - 인터페이스를 통해서 중요도 계산 로직을 다양하게 작성할 수 있다면 더 좋을 것 같음
    - 예) 현재의 `TextImportanceScorer`의 방식 대신 머신러닝을 사용한 방법을 이용할 수도 있음