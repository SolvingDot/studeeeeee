#### 복구 가능 여부

- 가능: 사용자가 잘못 입력, 네트워크 오류 등등
- 불가능: 하드코딩이 잘못됨, 프로그래머가 잘못 입력 등등

#### 실패하기

- 신속하게 실패하라: 오류가 발생한 지점으로부터 멀지 않은 지점에서 빠르게 실패하기
- 요란하게 실패하라: 오류 메세지 기록은 개발자에 따라 무시될 수 있으므로 명백하게 프로그램을 중단하기

- 복구가능성
    - 소프트웨어는 견고하게 (실패해도 동작 계속)
    - 오류를 알아차리지 못한 채 동작되지 않게 (요란하게 실패)
    - 절충안이 필요
- 잠시 편하겠다고 오류를 숨기지 말자
- 오류 숨기는 방법 (지양)
    - 기본값 반환
    - 널 객체 패턴 (빈 목록 반환)
    - 오류 발생 시 아무것도 하지 않음

### 오류 전달 방법

#### 명시적 방법: 오류를 인지할 수밖에 없도록 함 (오류를 모르고 넘어갈 수 없음) [좋은 방법!]

##### 1. 검사 예외(checked exception)를 통한 오류 전달

- 호출하는 쪽에서 예외를 인지하도록 강제 조치

  ```
  class NegativeNumberException extends Exception {
  ~~~
  }
  ```

- `Exception` 클래스를 확장함

##### 2. 널값이 가능한 반환 유형 사용 (널 안전성 지원 필요)

  ```
  Double? getSquareRoot(Double value) {
    if (value < 0.0) { 
      return null;
    }
    return Math.sqrt(value);
  }
  
  void displaySquareRoot() {
    Double? squareRoot = getSquareRoot(inputView.readInput());
    if (squareRoot == null) {
      inputView.setError("Can't get square root of a negative number");
    } else {
      inputView.setOutput("Square root is: " + squareRoot);
    }
  }
  ```

##### 3. `Result` 반환 유형

- 널값, 옵셔널 타입을 사용하는 경우의 문제점
    - 오류 정보를 전달할 수 없음
    - 호출하는 쪽에 값을 얻을 수 없음을 알리면서 이유까지 알려주면 좋음
- Swift, Rust, F#와 같은 언어에서 지원
- Optional 타입으로 value, error를 담아 구현하면 좋음! (자세한 내용은 찾아보기)

##### 4. Outcome 반환 유형

- 해당 내용을 수행하는데 성공하면 `true` 실패하면 `false`를 반환함
    - 좀 더 복잡한 시나리오를 구현해야 한다면 단순 불리언보다 더 정교한 아웃컴 유형을 사용하는 것이 더 적절할 수 있음
- 문제점은 호출하는 쪽에서 반환값을 무시하거나 함수가 값을 반환한다는 사실조차 인식하지 못할 수 있다는 점 (retainAll)

#### 암시적 방법: 호출하는 쪽에 오류를 알리지만, 신경쓰지 않아도 됨.

##### 1. 비검사 에외(unchecked exception)을 통한 오류 전달

- `RuntimeException` 클래스를 확장함
- 어떤 종류의 비검사 에외가 발생할 수 있는지 문서화하는 것이 권장 (의무는 아님)

##### 2. Promise, Future 사용

- 비동기적으로 실행하는 코드를 작성할 때 활용
    - 동기적: 작업을 한 번에 하나씩 순차적으로 수행
    - 비동기적: 다른 작업이 끝나기를 기다리는 동안 다른 작업을 수행할 수 있음
        - 케이크를 오븐에서 굽는 동안, 케이크 위에 올리는 크림을 만들 수 있음

##### 3. 매직값 만환

- 매직값: 함수의 정상적 반환 유형에 적합하지만 특별한 의미를 부여하는 값
    - 예) -1를 반환하는 경우
- 코드 계약의 명백한 부분을 통해 호출하는 쪽에 알릴 수 없어서 예상을 벗어나는 결과를 가져올 수 있고 버그로 이어질 수 있음
- 좋은 방법이 아님! 