## 객체지향 프로그래밍 1

##### 23 ~ 24

- 기본형 매개변수: 변수의 값을 읽기만 할 수 있다.
- 참조형 매개변수: 변수의 값을 읽고 변경할 수 있다.

#### 28 static은 언제 붙여야 할까?

1. 클래스를 설계할 때, 모든 인스턴스에서 같은 값이 유지되어야 하는 변수
2. 클래스 메서드(`static` 메서드)는 인스턴스 변수를 사용할 수 없다.
    - 인스턴스 변수는 인스턴스가 반드시 존재해야 사용 가능한데, 클래스 메서드는 인스턴스 생성 없이 호출 가능하므로 클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있음
3. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, `static`을 붙이는 것을 고려한다.
    - 호출 시간이 짧아지므로 성능이 향상된다.

#### 30 오버로딩

1. 메서드 이름이 같음
2. 매개변수의 개수, 또는 타입이 달라야함
3. 반환 타입은 관계 없음 (호출 시 어떤 메서드를 호출해야 하는지 구분할 수 없음)

#### 32 생성자

- **인스턴스 초기화 메서드**: 인스턴스 변수들을 초기화 (인스턴스 생성 X)
- 이름은 클래스의 이름과 같고, 리턴 값이 없음
- 클래스에 정의된 생성자가 하나도 없을 때에는 기본 생성자(아무것도 없음)가 자동으로 생성된다

#### 36 생성자에서 다른 생성자 호출하기 `this()`

- 두 가지 조건 만족 시, 오버로딩된 생성자 간에도 서로 호출 가능
    - 생성자의 이름으로 클래스이름 대신 `this` 사용
    - 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출 가능
        - 초기화 작업 도중 다른 생성자를 호출하면, 호출한 다른 생성자 내에서도 멤버변수들의 값을 초기화해 이전 초기화 작업이 무의미해질 수 있기 때문

```
Car() {
   this("white", "auto"4);
}

Car(String color) { 
   this(color, "auto", 4);
}
```

- 같은 클래스 내 생성자들은 일반적으로 서로 관계가 깊은 경우가 많아서 서로 호출하도록 하여 유기적으로 연결해주면 더 좋은 코드를 얻을 수 있음
- 수정이 필요한 경우, 적은 코드만 변경해주면 되어 유지보수가 편해짐

#### 37 객체 자신을 가리키는 참조변수 `this`

- 생성자의 매개변수와 인스턴스 변수의 이름이 같으면 구분이 안됨 => 인스턴스 변수 앞에 `this`를 사용한다.
- `this`는 참조변수로 인스턴스 자신을 가리킴
- `static` 메서드에서는 `this` 사용 불가
- 생성자를 포함한 모든 인스턴스 메서드에는 `this`가 지역변수로 숨겨진 채로 존재함

> - **this** 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있음
>- **this(), this(매개변수)** 같은 클래스의 다른 생성자를 호출할 때 사용
>- 비슷하게 생겼지만, 완전히 다른 것 !!!

#### 38 변수의 초기화

- 클래스 변수와 인스턴스 변수(자동으로 기본값으로 초기화), 배열의 초기화는 선택
- 지역변수의 초기화는 필수

#### 39 멤버변수의 초기화

1. 클래스 변수 초기화 => 인스턴스 변수 초기화
2. 자동 초기화 => 명시적 초기화 => 초기화 블럭, 생성자

- 명시적 초기화: 변수를 선언과 동시에 초기화 (간단)
- 초기화 블럭
    - 클래스 초기화 블럭
      ```
      static { 
       // 클래스 초기화 블럭
      // 처음 메모리에 로딩될 때 한번만 실행 
      }
      
      { 
      // 인스턴스 초기화 블럭
      // 인스턴스가 생성될 때마다 수행
      }
      ```

## 객체지향 프로그래밍 2

#### 1 상속

- 자손 클래스는 조상 클래스의 모든 멤버를 상속 받는다 (생성자, 초기화블럭 X)
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다 `extends`

