## 객체지향 프로그래밍 1

##### 23 ~ 24

- 기본형 매개변수: 변수의 값을 읽기만 할 수 있다.
- 참조형 매개변수: 변수의 값을 읽고 변경할 수 있다.

#### 28 static은 언제 붙여야 할까?

1. 클래스를 설계할 때, 모든 인스턴스에서 같은 값이 유지되어야 하는 변수
2. 클래스 메서드(`static` 메서드)는 인스턴스 변수를 사용할 수 없다.
    - 인스턴스 변수는 인스턴스가 반드시 존재해야 사용 가능한데, 클래스 메서드는 인스턴스 생성 없이 호출 가능하므로 클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있음
3. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, `static`을 붙이는 것을 고려한다.
    - 호출 시간이 짧아지므로 성능이 향상된다.

#### 30 오버로딩

1. 메서드 이름이 같음
2. 매개변수의 개수, 또는 타입이 달라야함
3. 반환 타입은 관계 없음 (호출 시 어떤 메서드를 호출해야 하는지 구분할 수 없음)

#### 32 생성자

- **인스턴스 초기화 메서드**: 인스턴스 변수들을 초기화 (인스턴스 생성 X)
- 이름은 클래스의 이름과 같고, 리턴 값이 없음
- 클래스에 정의된 생성자가 하나도 없을 때에는 기본 생성자(아무것도 없음)가 자동으로 생성된다

#### 36 생성자에서 다른 생성자 호출하기 `this()`

- 두 가지 조건 만족 시, 오버로딩된 생성자 간에도 서로 호출 가능
    - 생성자의 이름으로 클래스이름 대신 `this` 사용
    - 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출 가능
        - 초기화 작업 도중 다른 생성자를 호출하면, 호출한 다른 생성자 내에서도 멤버변수들의 값을 초기화해 이전 초기화 작업이 무의미해질 수 있기 때문

```
Car() {
   this("white", "auto"4);
}

Car(String color) { 
   this(color, "auto", 4);
}
```

- 같은 클래스 내 생성자들은 일반적으로 서로 관계가 깊은 경우가 많아서 서로 호출하도록 하여 유기적으로 연결해주면 더 좋은 코드를 얻을 수 있음
- 수정이 필요한 경우, 적은 코드만 변경해주면 되어 유지보수가 편해짐

#### 37 객체 자신을 가리키는 참조변수 `this`

- 생성자의 매개변수와 인스턴스 변수의 이름이 같으면 구분이 안됨 => 인스턴스 변수 앞에 `this`를 사용한다.
- `this`는 참조변수로 인스턴스 자신을 가리킴
- `static` 메서드에서는 `this` 사용 불가
- 생성자를 포함한 모든 인스턴스 메서드에는 `this`가 지역변수로 숨겨진 채로 존재함

> - **this** 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있음
>- **this(), this(매개변수)** 같은 클래스의 다른 생성자를 호출할 때 사용
>- 비슷하게 생겼지만, 완전히 다른 것 !!!

#### 38 변수의 초기화

- 클래스 변수와 인스턴스 변수(자동으로 기본값으로 초기화), 배열의 초기화는 선택
- 지역변수의 초기화는 필수

#### 39 멤버변수의 초기화

1. 클래스 변수 초기화 => 인스턴스 변수 초기화
2. 자동 초기화 => 명시적 초기화(간단한 내용) => 초기화 블럭, 생성자(복잡한 내용)

- 명시적 초기화: 변수를 선언과 동시에 초기화 (간단)
- 초기화 블럭
    - 클래스 초기화 블럭
      ```
      static { 
       // 클래스 초기화 블럭
      // 처음 메모리에 로딩될 때 한번만 실행 
      }
      
      { 
      // 인스턴스 초기화 블럭
      // 인스턴스가 생성될 때마다 수행
      }
      ```

## 객체지향 프로그래밍 2

#### 1 상속

- 자손 클래스는 조상 클래스의 모든 멤버를 상속 받는다 (생성자, 초기화블럭 X)
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다 `extends`

#### 3 클래스 간 포함관계

``` 
Class Circle { 
    int x;
    int y; 
    int r;
}

Class Point {
    int x;
    int y;
}
```

- `Point` 클래스를 재사용해서 `Circle` 클래스를 작성한다면,

``` 
class Circle {
    Point c = new Point();
    int r;
}
```

#### 4 상속 VS 포함

- is a / has a 로 문장을 만들어보자.
- Circle is a Point VS Circle has a Point
- 후자가 더 자연스럽다면, 포함관계를 맺어주는게 옳다

#### 7 오버라이딩

- 상속받은 메서드를 자손 클래스 자신에 맞게 변경해 사용하는 것

1. 메서드의 내용만을 새로 작성하는 것이므로, 선언부(이름, 매개변수, 반환타입)은 조상의 것과 완전히 일치해야 함
    - 접근 제어자, 예외는 제한된 조건 하에서 다르게 변경 가능
2. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다
3. 조상 클래스의 메서드보다 더 많은 수의 예외를 선언할 수 없다.

#### 9 오버로딩 VS 오버라이딩

- 오버로딩: 기존에 없던 새로운 메서드를 정의하는 것
- 오버라이딩: 상속받은 메서드의 내용을 변경하는 것

#### 19 `final`

- 마지막의, 변경될 수 없는
- 변수: 변경할 수 없는 상수
- 메서드: 오버라이딩을 할 수 없음
- 클래스: 확장하는 자손 클래스를 정의하지 못함

#### 20 `abstract`

- 미완성의
- 메서드: 메서드의 선언부만 작성하고 실제 수행내용을 구현하지 않은 추상 메서드를 선언하는데 사용됨
- 클래스: 클래스 내에 추상 메서드가 선언되어 있음을 의미함 = 추상 클래스
- 추상 클래스는 아직 완성되지 않은 메서드가 존재하므로 인스턴스를 생성할 수 없다

#### 21 접근 제어자

- `private`: 같은 클래스 내에서만
- `(default)`: 같은 패키지 내에서만
- `protected`: 같은 패키지 내, 다른 패키지의 자손 클래스에서
- `public`: 접근 제한이 없음

#### 23 다형성

``` 
class Tv { 
    boolean power;
    int channel;
    
    void power() { }
    void channelUp() { }
    void channelDown() { }
}

class SmartTv extends TV {
    String text;
    void caption() { }
}
```

- 조상 클래스인 `Tv`를 상속한 자손 클래스 `SmartTv`
- 생성된 인스턴스`new Tv()`를 다루기 위해 인스턴스 타입과 일치하는 타입의 참조변수`Tv t`를 사용해왔음

``` 
Tv t = new Tv();
SmartTv s = new SmartTv();
```

- 상속 관계에 있을 경우, 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하도록 하는 것이 가능하다!

``` 
Tv t = new SmartTv();
```

- 하지만 이렇게 하는 경우, 참조변수 `t`에는 조상 클래스를 담는 공간이 할당되어 있어서 새로 정의한 `text`와 `caption()`은 사용 불가
- 반대로 자손 타입의 참조변수로 조상 타입의 인스턴스를 참조할 수는 없다.

#### 24 참조변수의 형변환

- 상속 관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행될 수 있음
- 참조변수가 가리키는 인스턴스의 자손타입으로의 형변환은 허용되지 않음

## 예외 처리

#### 1 프로그램 오류

- 컴파일 에러: 컴파일 시에 발생하는 에러
- 런타임 에러: 프로그램 실행 도중에 발생하는 에러
- 논리적 에러: 컴파일도 잘 되고 실행도 잘 되지만 의도와 다르게 동작하는 것


- 에러: 프로그램 코드에 의해 수습될 수 없는 심각한 오류 (메모리 부족, 스택 오버플로우), 발생하면 복구할 수 없음
- 예외: 다소 미약한 오류

- 예외는 `Exception` 클래스의 후손, 에러는 `Error` 클래스의 후손

#### 3 `RuntimeException`

- `Exception` 클래스들: **사용자**의 실수와 같은 외적인 요인에 의해 발생
    - 주로 외부의 영향으로 발생
    - 입력한 데이터의 형식이 잘못됨 `DataFormatException`
- `RuntimeException` 클래스들: **프로그래머**의 실수로 발생
    - 배열 범위를 벗어남 `ArrayIndexOutOfBoundsException
    - 값이 `null`인 참조변수의 멤버를 호출하려 함 `NullPointerException`
    - 클래스간 형변환을 잘못함 `ClassCastException`
    - 정수를 0으로 나누려고 함 `ArithmeticException`

## java.lang패키지와 유용한 클래스

#### 11 String 클래스

- `char charAt(int index)` index에 있는 문자를 알려줌
- `int compareTo(String str)` 문자열과 사전 순서로 비교해, 같으면 0, 이전이면 -1, 이후면 1 반환
- `String concat(String str)` 문자열을 뒤에 덧붙임
- `contains` `endsWith` `equals` `equalsIgnoreCase` `indexOf(int ch)`
- `lastIndexOf` `replace(char old, char new)` `replaceAll(String regex, String replacement)` `replaceFirst`
- `split` `substring` `trim`

#### 12 `StringJoiner`

``` 
StringJoiner sj = new StringJoiner(",", "[", "]");
String[] strArr = {"aaa", "bbb", "ccc"};

for (String s : strArr) {
    sj.add(s.toUpperCase());
}

// [AAA, BBB, CCC]
```

#### 13 문자열과 기본형 간의 변환

- 문자 <==> 숫자
    - 기본형 ==> `String`
      ``` 
        int i = 100;
        String str1 = i + "";
        String str2 = String.valueOf(i);
      ```
    - `String` ==> 기본형
      ```
       int i = Integer.parseInt("100");
       int i2 = Integer.valueOf("100");
      ```
  